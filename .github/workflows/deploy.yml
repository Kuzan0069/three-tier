name: CI/CD with SonarCloud Quality Gate and EC2 Deployment

on:
  push:
    branches: [ main ]
    # Allow manual workflow execution from GitHub Actions UI
  workflow_dispatch:

jobs:
  build-test-deploy:
  # Use Ubuntu runner hosted on github
    runs-on: ubuntu-latest
    defaults:
      run:
      # directs it to the application-code folder as this is where the codebase resides
        working-directory: application-code

    steps:
      # ‚úÖ Step 1: Checkout your code
      - name: Checkout code
        uses: actions/checkout@v4
        with:
        # needed so SonarCloud can analyze code changes over time
          fetch-depth: 0

      # ‚úÖ Step 2: SonarCloud Code Analysis
      - name: SonarQube Scan
       # Use full commit SHA for security and immutability
        uses: sonarsource/sonarqube-scan-action@fd88b7d7ccbaefd23d8f36f73b59db7a3d246602
        with:
          projectBaseDir: application-code

           # SonarCloud configuration parameters
          args: >
            -Dsonar.projectKey=Kuzan0069_three-tier
            -Dsonar.organization=kuzan0069
            -Dsonar.sourceEncoding=UTF-8
            -Dsonar.sources=.
        env:
        # Authentication token for SonarCloud (stored as a GitHub secret)
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: "https://sonarcloud.io"

      # ‚úÖ Step 3: Login to Docker Hub
      - name: Docker Login
        uses: docker/login-action@9780b0c442fbb1117ed29e0efdff1e18412f7567
        with:
        # Docker Hub username and access token stored as GitHub secret. Ensure the token has its permission set to 'Read, Write, Delete'
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - run: echo "Logged in to Docker Hub successfully"

      # ‚úÖ Step 4: Build & Push Backend Image
      # Creates a Docker image for the Node.js backend and uploads it to Docker Hub
      - name: Build & Push Backend
        env:
        # Make Docker username available as environment variable
          DOCKER_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        run: |
          echo "Building backend image..."
          docker build -t $DOCKER_USERNAME/application-code-backend:latest ./app-tier
          
          echo "Pushing backend image to Docker Hub..."
          docker push $DOCKER_USERNAME/application-code-backend:latest

          echo "Backend image built and pushed successfully!"

      # ‚úÖ Step 5: Build & Push Frontend Image
      # Creates a Docker image for the React frontend and uploads it to Docker Hub
      - name: Build & Push Frontend
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        run: |
          echo "Building frontend image..."
          docker build -t $DOCKER_USERNAME/application-code-frontend:latest ./web-tier

          echo "Pushing frontend image to Docker Hub..."
          docker push $DOCKER_USERNAME/application-code-frontend:latest
          
          echo "Frontend image built and pushed successfully!"

      # ‚úÖ Step 6: SSH into EC2 and Deploy
      - name: SSH and Deploy
        uses: appleboy/ssh-action@2ead5e36573f08b82fbfce1504f1a4b05a647c6f
        with:
        # EC2 instance public IP address. Get an elastic IP address to avoid changing it everytime the instance restarts
          host: ${{ secrets.EC2_HOST }}

          # SSH username (typically 'ec2-user' for Amazon Linux, 'ubuntu' for Ubuntu...and so on)
          username: ${{ secrets.EC2_USER }}

          # Private SSH key for authentication (PEM file content)
          key: ${{ secrets.EC2_KEY }}

          # Pass environment variables through envs parameter. Makes variables available in ssh session and accessible on EC2
          envs: DOCKER_USERNAME,DOCKER_TOKEN,DB_ROOT_PASSWORD,DB_NAME,DB_USER,DB_PASSWORD
          script: |
            echo "üîë Connecting to EC2 instance..."
            # Uses stdin for secure password input (prevents exposure in shell history)
            echo "$DOCKER_TOKEN" | docker login -u "$DOCKER_USERNAME" --password-stdin
            echo "Docker login on EC2 successful!"

            echo "Stopping old containers..."
            # Stop running containers
            docker stop frontend backend db 2>/dev/null || true
            # Remove stopped containers (not images) to free up resources
            docker rm frontend backend db 2>/dev/null || true
            echo "Old containers stopped and removed."

            echo "üì¶ Pulling latest images from Docker Hub..."
            # Download the latest versions of all required images
            docker pull $DOCKER_USERNAME/application-code-frontend:latest
            docker pull $DOCKER_USERNAME/application-code-backend:latest
            docker pull mysql:5.7
            echo "Images pulled successfully!"

            echo "Starting database container..."
            # Check if DB_USER is 'root' and handle accordingly
            if [ "$DB_USER" = "root" ]; then
              echo "Using root user for database..."
              docker run -d --name db \
                -e MYSQL_ROOT_PASSWORD="$DB_ROOT_PASSWORD" \
                -e MYSQL_DATABASE="$DB_NAME" \
                -p 3306:3306 \
                mysql:5.7
            else
              echo "Creating non-root database user..."
              docker run -d --name db \
                -e MYSQL_ROOT_PASSWORD="$DB_ROOT_PASSWORD" \
                -e MYSQL_DATABASE="$DB_NAME" \
                -e MYSQL_USER="$DB_USER" \
                -e MYSQL_PASSWORD="$DB_PASSWORD" \
                -p 3306:3306 \
                mysql:5.7
            fi
            echo "Database container started. Waiting for MySQL to be ready..."
            
            # Wait for MySQL to be ready (max 90 seconds)
            COUNTER=0
            MAX_TRIES=90
            until docker exec db mysqladmin ping -h localhost --silent 2>/dev/null; do
              COUNTER=$((COUNTER+1))
              if [ $COUNTER -gt $MAX_TRIES ]; then
                echo "‚ùå MySQL failed to start within 90 seconds"
                docker logs db
                exit 1
              fi
              echo "‚è≥ Waiting for MySQL to be ready... ($COUNTER/$MAX_TRIES)"
              sleep 1
            done
            echo "‚úÖ MySQL is ready!"
            
            # Extra wait to ensure MySQL is fully initialized. Prevents race conditions during database/table creation
            sleep 5

            echo "‚öôÔ∏è Starting backend container..."
            docker run -d --name backend \
              --env DB_HOST=db \
              --env DB_USER="$DB_USER" \
              --env DB_PWD="$DB_PASSWORD" \
              --env DB_DATABASE="$DB_NAME" \
              -p 4000:4000 \
              --link db:db \
              $DOCKER_USERNAME/application-code-backend:latest
            echo "Backend container running."

            echo "Starting frontend container..."
            docker run -d --name frontend \
              -p 3000:80 \
              --link backend:backend-container \
              $DOCKER_USERNAME/application-code-frontend:latest
            echo "Frontend container running."
            
            echo "‚úÖ Deployment completed! Checking container status..."
            docker ps

        # Environment variables block
        # These are defined here and passed to the SSH session via the 'envs' parameter
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKER_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          DB_ROOT_PASSWORD: ${{ secrets.DB_ROOT_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}